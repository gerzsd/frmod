<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>frmod.analysis API documentation</title>
<meta name="description" content="Frequency ratio model analysis …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>frmod.analysis</code></h1>
</header>
<section id="section-intro">
<p>Frequency ratio model analysis.</p>
<p>Perform a landslide susceptibility analysis with the frequency ratio method.</p>
<p>@author: Dávid Gerzsenyi</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Frequency ratio model analysis.

Perform a landslide susceptibility analysis with the frequency ratio method.

@author: Dávid Gerzsenyi
&#34;&#34;&#34;

import os

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

import frmod.utils as utils


def get_freq_ratios(vr,
                    mask,
                    binc=100,
                    nodata=-9999.,
                    categorical=False,
                    normalize=False,
                    ls_marker=1,
                    nls_marker=0):
    &#34;&#34;&#34;
    Get the frequency ratio of the landslide and non-landslide parts.

    Parameters
    ----------
    vr : Array
        The array of the analyzed variable. Numeric values.
    mask : Array
        The array of the mask.
    binc : int, optional
        Bin count for the histogram of the non-categorical variables.
        The default is 100.
    categorical : bool, optional
        Set true if the analysed variable raster is categorical.
        Categories must be marked with unique integers in the rasters.
        The dafault is False.
    normalize : bool, optional
        Set True for normalized weights (0, 1)
        The default is False.
    ls_marker : int, optional
        The value marking the landslide parts.
        The default is 1.
    nls_marker : int, optional
        The value marking the non-landslide parts.
        The default is 0.

    Returns
    -------
    frequency_ratios : Array
        The frequency ratio values. Length: number of bins.
    hst_bins : Array
        Array containing the edges of the bins. Length: number of bins + 1.

    &#34;&#34;&#34;
    ls_area = np.count_nonzero(mask == ls_marker)
    nls_area = np.count_nonzero(mask == nls_marker)
    if categorical:
        bin_edges = np.unique(vr[(vr != nodata)])
        bin_edges = np.append(bin_edges, bin_edges[-1] + 1)
        ls_hst = np.histogram(vr[mask == ls_marker],
                              bins=bin_edges,
                              density=False)
        nls_hst = np.histogram(vr[mask == nls_marker],
                               bins=bin_edges,
                               density=False)
    else:
        glob_lim = (vr[vr != nodata].min(),
                    vr[vr != nodata].max())
        ls_hst = np.histogram(vr[mask == ls_marker], bins=binc,
                              range=glob_lim, density=False)
        nls_hst = np.histogram(vr[mask == nls_marker], bins=binc,
                               range=glob_lim, density=False)
    # Histogram density for the landslide part
    ls_hst_d = ls_hst[0] / ls_area
    # Histogram density for the non-landslide part
    nls_hst_d = nls_hst[0] / nls_area
    # Histogram bins
    hst_bins = ls_hst[1]
    mn = hst_bins[:-1]
    mx = hst_bins[1:]
    # Frequency ratios
    fr = ls_hst_d / nls_hst_d
    if normalize:
        frequency_ratios = (fr - fr.min()) / (fr.max() - fr.min())
    else:
        frequency_ratios = fr
    # Create a pd.DataFrame for the bins, densities, and the frequency ratio
    data = [mn, mx, ls_hst_d, nls_hst_d, frequency_ratios]
    # columns = [&#34;Min&#34;, &#34;Max&#34;, &#34;LS_density&#34;, &#34;NLS_density&#34;, &#34;frequency_ratio&#34;]
    data = {&#39;min&#39;: mn,
            &#39;max&#39;: mx,
            &#39;LS_density&#39;: ls_hst_d,
            &#39;NLS_density&#39;: nls_hst_d,
            &#39;frequency_ratio&#39;: fr}
    fr_stat_df = pd.DataFrame(data=data)
    return frequency_ratios, hst_bins, fr_stat_df


# TODO: a name change is due to reclass_array
# TODO Use more generic variable names. This can reclass any array.
def reclass_raster(vr, f_ratios, bin_edges, verbose=False):
    &#34;&#34;&#34;
    Create an array with the frequency ratios.

    Parameters
    ----------
    vr : Array
        Array of the analysed variable to be reclassified.
    f_ratios : Array
        The frequency ratio values. Length: number of bins.
    bin_edges : Array
        Array containing the edges of the bins. Length: number of bins + 1.
    verbose : bool
        Set True to print the bin ranges and reclass values.

    Returns
    -------
    reclassed : Array
        Reclassified array with the appropriate frequency ratio values.

    &#34;&#34;&#34;
    reclassed = np.ones(vr.shape) * -99999
    for i in range(0, len(f_ratios)):
        # Reclassifying the raster by assigning the frequency ratio
        # values of each bin to the corresponding raster values.
        mn = bin_edges[:-1][i]
        mx = bin_edges[1:][i]
        vrange = mx - mn
        to_reclass = (vr &gt;= mn) &amp; (vr &lt; mx)
        reclassed[to_reclass] = f_ratios[i]
        if verbose:
            print(&#34;Min: {} Max: {} Range: {} Ratio: {}&#34;.format(
                mn, mx, vrange, f_ratios[i])
                 )
    return reclassed


def show_grid(grid, nodata, name=&#39;Grid&#39;, **kwargs):
    &#34;&#34;&#34;
    Plot a grid, nodata values are masked.

    Plot a grid (2D array). Values equal to nodata will be masked.
    **kwargs are keywords passed to matplotplit.pyplot.imshow that
    is used for plotting the masked grid. Eg. color maps (cmap).

    Parameters
    ----------
    grid : Array
        Grid to plot.
    nodata : int / float
        Nodata value of the grid. Nodata values will be masked.
    name : str, optional
        The title of the plot. The default is &#39;Grid&#39;.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    masked_grid = np.ma.masked_where((grid == nodata), grid)
    plt.figure()
    plt.title(name)
    plt.imshow(masked_grid, **kwargs)
    plt.colorbar()
    plt.show()


class VRaster():
    &#34;&#34;&#34;Variable raster, input for frequency ratio analysis.&#34;&#34;&#34;

    def __init__(self, name, path, bins=10, categorical=False):
        &#34;&#34;&#34;
        Create the VRaster object.

        Parameters
        ----------
        name : str
            Name of the VRaster.
        path : str
            Path to the GDAL-compatible raster file.
        bins : int, optional
            Number of histogram bins. The default is 10.
        categorical : bool, optional
            True if it is a categorical variable, eg: geology.
            The default is False.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        self.name = name
        self.path = path
        self.bins = bins
        self.categorical = categorical
        self.nodata = utils.get_nodata_value(path)
        # Convert input grid to array
        self.grid = utils.raster2array(path)
        # Calculate basic statistics for the grid
        self.min = min(self.grid[self.grid != self.nodata])
        self.max = max(self.grid[self.grid != self.nodata])
        self.limits = (self.min, self.max)

    def show(self, **kwargs):
        &#34;&#34;&#34;
        Plot the VRaster.grid.

        Parameters
        ----------
        **kwargs :
            Keywords passed to show_grid.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        show_grid(self.grid, self.nodata, name=self.name, **kwargs)

    def show_info(self):
        &#34;&#34;&#34;
        Show basic information about the VRaster.grid.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        valid_values = self.grid[self.grid != self.nodata]
        if self.categorical:
            print(&#34;Categorical!&#34;)
        else:
            average = np.mean(valid_values)
            sdev = np.std(valid_values)
            print(&#34;Name: {} Limits: {}&#34;.format(self.name, self.limits))
            print(&#34;Mean: {} Standard deviation: {}&#34;.format(average, sdev))


class LandslideMask():
    &#34;&#34;&#34;LandslideMask.&#34;&#34;&#34;

    def __init__(self, name, path, ls_marker=1, nls_marker=0, fold_count=5):
        &#34;&#34;&#34;
        Create a LandslideMask object.

        Parameters
        ----------
        name : str
            Name of the landslide mask.
        path : str
            Path to the file used as the mask in the analysis.
        ls_marker : int, optional
            Value marking the landslide pixels.
            The default is 1.
        nls_marker : int, optional
            Value marking the non-landslide pixels.
            Must be different from the nodata value.
            The default is 0.
        fold_count : int, optional
            The number of cross validation folds. The default is 5.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        # Name of the LandslideMask
        self.name = name
        # Path to the input mask file.
        self.path = path
        # NoData value of the input mask file.
        self.nodata = utils.get_nodata_value(path)
        # 2D array representation of the input mask file.
        self.grid = utils.raster2array(path)
        # Value marking the landslide cells.
        self.ls_marker = ls_marker
        # Value marking the non-landslide cells. Different from nodata!
        self.nls_marker = nls_marker
        # Number of folds
        self.fold_count = fold_count
        # (fold_count no. of (2, n) size arrays) with the split positions
        self.split_locations = self.get_splits(folds=self.fold_count)
        # List of (train_areas, valid_positions) ndarray pairs.
        self.t_v = [self.get_train_area(a) for a in self.split_locations]
        # Training areas (1), validation cells count as non-landslide.
        # Input mask for get_freq_ratios.
        self.train_areas = [t_v[0] for t_v in self.t_v]
        # Positions of the validation cells.
        self.valid_positions = [t_v[1] for t_v in self.t_v]

    def get_splits(self, folds=5):
        &#34;&#34;&#34;
        Split the mask for cross validation.

        Parameters
        ----------
        folds : TYPE, optional
            Number of desired folds. The default is 5.

        Returns
        -------
        split_locations : list of ndarrays
            (fold_count no. of (2, n) size arrays) with the split positions.

        &#34;&#34;&#34;
        valid = np.array(np.nonzero(self.grid == self.ls_marker))
        valid_transposed = valid.T
        np.random.shuffle(valid_transposed)
        valid_transposed_split = np.array_split(valid_transposed, folds)
        split_locations = [i.T for i in valid_transposed_split]
        return split_locations

    def get_train_area(self, split_to_omit):
        &#34;&#34;&#34;
        Get the train_area grid and the validation cell positions.

        Parameters
        ----------
        split_to_omit : list
            List of the position of the validation cells. It is used
            to construct the valid_position array. Cells marked here
            are turned into non-landslide cells.

        Returns
        -------
        train_area : list
            List of train area grids. Similar format to the self.grid.
        valid_position : list
            Lists the positions of the validation cells for the folds.
            Positions are given as two arrays:
                1st: row index increasing from top to bottom.
                2nd: column index increasing from left to right.

        &#34;&#34;&#34;
        train_area = np.copy(self.grid)
        valid_position = (split_to_omit[0], split_to_omit[1])
        train_area[valid_position] = self.nls_marker
        return train_area, valid_position

    def show(self, cmap=&#39;Accent&#39;):
        &#34;&#34;&#34;
        Plot the LandslideMask.grid.

        Parameters
        ----------
        cmap : str, optional
            Must be the name of a built-in Matplotlib colormap.
            The default is &#39;Accent&#39;.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        show_grid(self.grid, self.nodata, name=self.name, cmap=cmap)


class FRAnalysis():
    &#34;&#34;&#34;Frequency ratio analysis of a LandslideMask and a list of VRasters.

    The steps of the analysis:

    1. run_analysis() is run upon instantiation for each fold of the
        ls_mask and each VRaster. This yields the frequency ratio statistics
        and the reclassified grids.
    2. get_result() Compute the susceptibility grid and other related data.
    3. get_src() Compute the success rate curves.
        The success rate curve is the cumulative frequency distribution
        of the landslide cells in the susceptibility categories.
        Computed for each fold.
    4. get_auc() Compute the area under the success rate curves for scoring.
        Computed for each fold, then averaged for an overall score.
        Smaller values are better.
    &#34;&#34;&#34;

    def __init__(self, ls_mask, var_list):
        &#34;&#34;&#34;
        Create the FRAnalysis object.

        Create the FRAnalysis object and its instanced variables.
        The last step of the instantiation is creating the rc_folds list.
        The rc_folds holds the reclassified VRaster.grid-s for the folds 
        of the ls_mask for each VRaster in the var_list.

        Parameters
        ----------
        ls_mask : LandslideMask
            The LandslideMask object for the analysis.
        var_list : list
            List of VRaster objects to be analyzed.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        # Input LandslideMask
        self.ls_mask = ls_mask
        # List of input VRasters
        self.var_list = var_list
        # Number of VRasters
        self.var_count = len(var_list)

        # AUC, area under the success rate curve
        # Sum of the success_rates of the folds
        self.auc_folds = []
        # Mean AUC
        self.auc_mean = None
        # Standard deviations of the AUCs
        self.auc_std = None

        # Percentile bins of the fresult
        self.ranks = None
        # Fold_susceptibility, the susceptibility grids of the folds
        self.fold_susceptibility = None
        # Final result, the mean estimated susceptibility map over the folds.
        self.fresult = None
        # Final result in the percentile form
        self.percentile_grid = None

        # Susceptibility value bins for the percentiles
        self.valid_perc = []

        # The distributions of % ranks for the validation cells.
        self.v_dist = []
        # Bins for the above v_dist for conversion to percentiles
        self.v_bins = []

        # Frequency ratio analysis results for each VRaster and fold.
        self.stats = {}

        # Frequency ratio analysis results for each VRaster and fold.
        # keyword: VRaster.name
        # value: list of pd.DataFrames, 1 DF / fold
        self.fr_stats_full = {}

        # List of success rates for the folds.
        self.success_rates = None
        # pandas DataFrame of the success rates for the folds.
        self.src_df = None

        # Reclassified grids for each variable and fold
        # Shape: [var_count, ls_mask.fold_count, rows, columns]
        self.rc_folds = [self.run_analysis(vraster, self.ls_mask)
                         for vraster in self.var_list]

    def run_analysis(self, vrr, lsm):
        &#34;&#34;&#34;
        Frequency ratio analysis of one VRaster and the LandslideMask folds.

        Parameters
        ----------
        vrr : VRaster
            Supplies the grid and other parameters for the
            get_freq_ratios function.
        lsm : LandslideMask
            Supplies the input masks for the get_freq_ratios functions.

        Returns
        -------
        rc_folds : ndarray
            The reclassified grids after the frequency ratio analysis of the
            VRaster and each fold of the LandslideMask.
            Shape: (self.var_count, lsm.fold_count, vrr.shape[0], vrr.shape[1])

        &#34;&#34;&#34;
        # Array for storing the reclassified VRaster.grids for the folds
        rc_folds = []
        # Create arrays for the statistics
        all_frq_ratios = []
        all_hst_bins = []
        all_folds_statistics = []

        # Run the analysis with the training areas of the different folds
        # Iterating over the train_areas of the folds
        for msk in lsm.train_areas:
            fr_data = get_freq_ratios(vr=vrr.grid,
                                      mask=msk,
                                      binc=vrr.bins,
                                      nodata=vrr.nodata,
                                      categorical=vrr.categorical,
                                      normalize=False
                                      )
            frq_ratios = fr_data[0]
            hst_bins = fr_data[1]
            # pd.DataFrame with the densities and the frequency ratios
            all_folds_statistics.append(fr_data[2])
            # Prepare the statistics DataFrame
            all_frq_ratios.append(frq_ratios)
            all_hst_bins.append(hst_bins)
            # Reclassify the VRaster.grid
            reclassed = reclass_raster(vrr.grid, frq_ratios, hst_bins)
            # Append the reclassified VRaster.grid to rc_folds
            rc_folds.append(reclassed)

        # Adding all_folds_statistics DF to the fr_stats_full dict
        self.fr_stats_full[vrr.name] = all_folds_statistics

        # Creating the pd.DataFrame for the frequency ratio statistics
        mn = all_hst_bins[0][:-1]
        mx = all_hst_bins[0][1:]
        stat_df = pd.DataFrame({(vrr.name+&#39;_min&#39;): mn, (vrr.name+&#39;_max&#39;): mx})
        for i in range(0, lsm.fold_count):
            cname = &#34;fold_&#34;+str(i+1)
            stat_df.insert(i+2, cname, all_frq_ratios[i])
        # Add the stats pd.DataFrame to the stats dict
        self.stats[vrr.name] = stat_df
        return rc_folds

    def get_result(self):
        &#34;&#34;&#34;
        Get the susceptibility estimation and ranks.

        Returns
        -------
        self.ranks : ndarray
            Numpy array (101,) with the percentile bins.

        &#34;&#34;&#34;
        rc_folds = self.rc_folds
        valid_positions = self.ls_mask.valid_positions
        result = []
        percentile_result = []
        # percentile bins
        percentile_bins = [x * 0.01 for x in range(0, 101)]
        # Iterate over the folds of the ls_mask.
        for i in range(0, self.ls_mask.fold_count):
            fold_result = np.zeros(rc_folds[0][0].shape)
            # Iterate over the reclassified grids of fold #i
            for j in rc_folds:
                # Average the reclassified  grids of fold #i.
                fold_result += j[i] / self.var_count

            # Percentile bin edges for conversion to percentiles
            valid_perc = np.quantile(fold_result[fold_result &gt;= 0],
                                     percentile_bins,
                                     interpolation=&#39;nearest&#39;)

            self.valid_perc.append(valid_perc)
            v_to_score = fold_result[valid_positions[i]]
            v_dist, v_bins = np.histogram(v_to_score,
                                          valid_perc,
                                          density=False)

            v_dist = np.array(v_dist)
            v_dist = v_dist / sum(v_dist)
            # Append the probability density function to vdist
            self.v_dist.append(v_dist)
            self.v_bins.append(v_bins)
            result.append(fold_result)

        # fresult: cell by cell average of the result array
        fresult = sum(result) / self.ls_mask.fold_count

        # Assigning the results from the validation folds to the location
        # of the landslide mask
        for i in range(0, self.ls_mask.fold_count):
            fresult[valid_positions[i]] = result[i][valid_positions[i]]
        # Set all invalid values (&lt;0) to -99999 (nodata)
        fresult[fresult &lt; 0] = -99999

        # TODO Convert fold_susceptibility to percentiles
        self.fold_susceptibility = result
        self.fresult = fresult
        percentiles = [i*0.01 for i in range(0, 101)]
        self.ranks = np.quantile(fresult[fresult &gt; 0], percentiles)
        return self.ranks

    def get_src(self):
        &#34;&#34;&#34;
        Get success rate arrays for the folds.

        Returns
        -------
        success_rates : ndarray
            Cumulative sum of the v_dist arrays of the folds.

        &#34;&#34;&#34;
        success_rates = []
        for i in self.v_dist:
            success_rates.append(np.cumsum(i))
        self.success_rates = success_rates
        # Create the dataframe
        percentiles = [i + 1 for i in range(0, 100)]
        src_df = pd.DataFrame({&#34;percentile&#34;: percentiles})
        for i in range(0, self.ls_mask.fold_count):
            cname = &#34;fold_&#34;+str(i+1)
            src_df.insert(i+1, cname, success_rates[i])
        self.src_df = src_df
        return success_rates

    def get_auc(self):
        &#34;&#34;&#34;
        Get AUC, area under the success rate curve.

        Returns
        -------
        list
            AUC values for the folds.

        &#34;&#34;&#34;
        for i in self.success_rates:
            auc_of_fold = np.sum(i)
            self.auc_folds.append(auc_of_fold)
            print(&#34;Auc: {}&#34;.format(auc_of_fold))
        self.auc_mean = np.mean(self.auc_folds)
        self.auc_std = np.std(self.auc_folds)
        print(&#34;Mean score: {}; Std: {}&#34;.format(self.auc_mean, self.auc_std))
        return self.auc_folds

    def get_percentile_grid(self, show=False, **kwargs):
        &#34;&#34;&#34;
        Reclass the fresult to get its percentile form.

        Parameters
        ----------
        show : bool, optional
            Set True to plot the percentile_grid after computing it.
            The default is False.
        **kwargs :
            Keywords passed to show_grid.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        percent = [i for i in range(1, 101)]
        percentile_grid = reclass_raster(self.fresult, percent, self.ranks)
        self.percentile_grid = percentile_grid
        if show:
            show_grid(grid=percentile_grid,
                      nodata=-99999,
                      name=&#34;Susceptibility (percentiles)&#34;,
                      **kwargs)

    def save_src(self, folder=&#34;./output/&#34;, fname=&#34;src.csv&#34;):
        &#34;&#34;&#34;
        Save the success rates as csv.

        Parameters
        ----------
        folder : str, optional
            Path to the output folder. The default is &#34;./output/&#34;.
        fname : str, optional
            Output filename with extension. The default is &#34;src.csv&#34;.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        if os.path.isdir(folder) is False:
            os.makedirs(folder)
        output_path = folder+fname
        self.src_df.to_csv(output_path)

    def save_stats(self, folder=&#34;./output/&#34;, tag=&#34;&#34;):
        &#34;&#34;&#34;
        Save the frequency ratio statistics for each VRaster and fold.

        Parameters
        ----------
        folder : str, optional
            Path to the output folder. The default is &#34;./output/&#34;.
        tag : str, optional
            Tag inserted to the beginning of the file name.
            The default is &#34;&#34;.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        output_path = folder+tag
        # Create the folder directory if it doesn&#39;t exist.
        if os.path.isdir(folder) is False:
            os.makedirs(folder)

        for k, v in self.stats.items():
            v.to_csv(output_path+&#34;_{}.csv&#34;.format(str(k)))

    def show_results(self, **kwargs):
        &#34;&#34;&#34;
        Plot fresult with show_grid.

        Plot fresult, the raw estimated landslide susceptibility.
        **kwargs can be keywords passed to matplotlib.pyplot.imshow

        Returns
        -------
        None.

        &#34;&#34;&#34;
        if self.fresult.any(None):
            show_grid(grid=self.fresult,
                      nodata=-99999,
                      name=&#39;Estimated susceptibility&#39;,
                      **kwargs)
        else:
            print(&#34;Use get_result() first!&#34;)

    def plot_success_rates(self):
        &#34;&#34;&#34;
        Plot the success rate curves.

        The success rate curve shows the cumulative distribution of
        test landslide cells (pixels) in the susceptibility categories.

        Returns
        -------
        fig : figure.Figure
            A figure for the success rate curves.
        ax : matplotlib.axes.__subplots.AxesSubplot
           The axes of the figure.

        &#34;&#34;&#34;
        fig, ax = plt.subplots()
        label = 1
        for i in self.success_rates:
            ax.plot(i, label=label)
            label += 1
        ax.set_xlim(left=0, right=99)
        ax.set_ylim(bottom=0, top=1.0)
        diag_line, = ax.plot(ax.get_xlim(), ax.get_ylim(), ls=&#34;--&#34;, c=&#34;.3&#34;)
        ax.legend()
        plt.show()
        return fig, ax

    def plot_var_fold_fr(self, name, fold):
        &#34;&#34;&#34;
        Plot the densities and the frequency ratio for a fold of one variable.

        The function handles a pd.DataFrame from the fr_stats_full dict.
        The df DataFrame is selected in the following way:
        df = self.fr_stats_full[name][fold]

        Parameters
        ----------
        name : str
            A key in fr_stats_full.
        fold : int
            Index of the fold in the self.fr_stats_full[name] list.

        Returns
        -------
        fig : figure.Figure
            A figure with two subplots on top of each other.
        ax1 : matplotlib.axes.__subplots.AxesSubplot
            1st axes of the figure. Located in the top part.
        ax2 : matplotlib.axes.__subplots.AxesSubplot
            2nd axes of the figure. Located in the bottom part.
        line_LS : matplotlib.lines.Line2D
            The &#34;landslide&#34; line of the 1st axes.
        line_NLS : matplotlib.lines.Line2D
            The &#34;non-landslide&#34; line of the 1st axes.
        line_fr : matplotlib.lines.Line2D
            The frequency ratio curve on the 2nd axes.
            &#34;landslide&#34; line / &#34;non-landslide&#34; line

        &#34;&#34;&#34;
        df = self.fr_stats_full[name][fold]
        fig, (ax1, ax2) = plt.subplots(2, 1)
        ax1.set_xlabel(&#34;Distribution of {} values in the LS and NLS areas&#34;.
                       format(name))
        ax2.set_xlabel(&#34;{} - fold: {}&#34;.format(name, (fold + 1)))
        line_LS, = ax1.plot(df[&#34;min&#34;], df[&#34;LS_density&#34;])
        line_NLS, = ax1.plot(df[&#34;min&#34;], df[&#34;NLS_density&#34;])
        line_fr = ax2.plot(df[&#34;min&#34;], df[&#34;frequency_ratio&#34;])
        ax1.set_ylim(bottom=0)
        ax2.set_ylim(bottom=0)
        ax1.set_xlim(left=df[&#34;min&#34;][0])
        ax2.set_xlim(left=df[&#34;min&#34;][0])
        ax2.set_ylabel(&#34;Frequency ratio&#34;)
        plt.tight_layout()
        plt.show()
        # Return the parts of the figure
        return fig, ax1, ax2, line_LS, line_NLS, line_fr</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="frmod.analysis.get_freq_ratios"><code class="name flex">
<span>def <span class="ident">get_freq_ratios</span></span>(<span>vr, mask, binc=100, nodata=-9999.0, categorical=False, normalize=False, ls_marker=1, nls_marker=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the frequency ratio of the landslide and non-landslide parts.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>vr</code></strong> :&ensp;<code>Array</code></dt>
<dd>The array of the analyzed variable. Numeric values.</dd>
<dt><strong><code>mask</code></strong> :&ensp;<code>Array</code></dt>
<dd>The array of the mask.</dd>
<dt><strong><code>binc</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Bin count for the histogram of the non-categorical variables.
The default is 100.</dd>
<dt><strong><code>categorical</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Set true if the analysed variable raster is categorical.
Categories must be marked with unique integers in the rasters.
The dafault is False.</dd>
<dt><strong><code>normalize</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Set True for normalized weights (0, 1)
The default is False.</dd>
<dt><strong><code>ls_marker</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The value marking the landslide parts.
The default is 1.</dd>
<dt><strong><code>nls_marker</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The value marking the non-landslide parts.
The default is 0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>frequency_ratios</code></strong> :&ensp;<code>Array</code></dt>
<dd>The frequency ratio values. Length: number of bins.</dd>
<dt><strong><code>hst_bins</code></strong> :&ensp;<code>Array</code></dt>
<dd>Array containing the edges of the bins. Length: number of bins + 1.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_freq_ratios(vr,
                    mask,
                    binc=100,
                    nodata=-9999.,
                    categorical=False,
                    normalize=False,
                    ls_marker=1,
                    nls_marker=0):
    &#34;&#34;&#34;
    Get the frequency ratio of the landslide and non-landslide parts.

    Parameters
    ----------
    vr : Array
        The array of the analyzed variable. Numeric values.
    mask : Array
        The array of the mask.
    binc : int, optional
        Bin count for the histogram of the non-categorical variables.
        The default is 100.
    categorical : bool, optional
        Set true if the analysed variable raster is categorical.
        Categories must be marked with unique integers in the rasters.
        The dafault is False.
    normalize : bool, optional
        Set True for normalized weights (0, 1)
        The default is False.
    ls_marker : int, optional
        The value marking the landslide parts.
        The default is 1.
    nls_marker : int, optional
        The value marking the non-landslide parts.
        The default is 0.

    Returns
    -------
    frequency_ratios : Array
        The frequency ratio values. Length: number of bins.
    hst_bins : Array
        Array containing the edges of the bins. Length: number of bins + 1.

    &#34;&#34;&#34;
    ls_area = np.count_nonzero(mask == ls_marker)
    nls_area = np.count_nonzero(mask == nls_marker)
    if categorical:
        bin_edges = np.unique(vr[(vr != nodata)])
        bin_edges = np.append(bin_edges, bin_edges[-1] + 1)
        ls_hst = np.histogram(vr[mask == ls_marker],
                              bins=bin_edges,
                              density=False)
        nls_hst = np.histogram(vr[mask == nls_marker],
                               bins=bin_edges,
                               density=False)
    else:
        glob_lim = (vr[vr != nodata].min(),
                    vr[vr != nodata].max())
        ls_hst = np.histogram(vr[mask == ls_marker], bins=binc,
                              range=glob_lim, density=False)
        nls_hst = np.histogram(vr[mask == nls_marker], bins=binc,
                               range=glob_lim, density=False)
    # Histogram density for the landslide part
    ls_hst_d = ls_hst[0] / ls_area
    # Histogram density for the non-landslide part
    nls_hst_d = nls_hst[0] / nls_area
    # Histogram bins
    hst_bins = ls_hst[1]
    mn = hst_bins[:-1]
    mx = hst_bins[1:]
    # Frequency ratios
    fr = ls_hst_d / nls_hst_d
    if normalize:
        frequency_ratios = (fr - fr.min()) / (fr.max() - fr.min())
    else:
        frequency_ratios = fr
    # Create a pd.DataFrame for the bins, densities, and the frequency ratio
    data = [mn, mx, ls_hst_d, nls_hst_d, frequency_ratios]
    # columns = [&#34;Min&#34;, &#34;Max&#34;, &#34;LS_density&#34;, &#34;NLS_density&#34;, &#34;frequency_ratio&#34;]
    data = {&#39;min&#39;: mn,
            &#39;max&#39;: mx,
            &#39;LS_density&#39;: ls_hst_d,
            &#39;NLS_density&#39;: nls_hst_d,
            &#39;frequency_ratio&#39;: fr}
    fr_stat_df = pd.DataFrame(data=data)
    return frequency_ratios, hst_bins, fr_stat_df</code></pre>
</details>
</dd>
<dt id="frmod.analysis.reclass_raster"><code class="name flex">
<span>def <span class="ident">reclass_raster</span></span>(<span>vr, f_ratios, bin_edges, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Create an array with the frequency ratios.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>vr</code></strong> :&ensp;<code>Array</code></dt>
<dd>Array of the analysed variable to be reclassified.</dd>
<dt><strong><code>f_ratios</code></strong> :&ensp;<code>Array</code></dt>
<dd>The frequency ratio values. Length: number of bins.</dd>
<dt><strong><code>bin_edges</code></strong> :&ensp;<code>Array</code></dt>
<dd>Array containing the edges of the bins. Length: number of bins + 1.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>Set True to print the bin ranges and reclass values.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>reclassed</code></strong> :&ensp;<code>Array</code></dt>
<dd>Reclassified array with the appropriate frequency ratio values.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reclass_raster(vr, f_ratios, bin_edges, verbose=False):
    &#34;&#34;&#34;
    Create an array with the frequency ratios.

    Parameters
    ----------
    vr : Array
        Array of the analysed variable to be reclassified.
    f_ratios : Array
        The frequency ratio values. Length: number of bins.
    bin_edges : Array
        Array containing the edges of the bins. Length: number of bins + 1.
    verbose : bool
        Set True to print the bin ranges and reclass values.

    Returns
    -------
    reclassed : Array
        Reclassified array with the appropriate frequency ratio values.

    &#34;&#34;&#34;
    reclassed = np.ones(vr.shape) * -99999
    for i in range(0, len(f_ratios)):
        # Reclassifying the raster by assigning the frequency ratio
        # values of each bin to the corresponding raster values.
        mn = bin_edges[:-1][i]
        mx = bin_edges[1:][i]
        vrange = mx - mn
        to_reclass = (vr &gt;= mn) &amp; (vr &lt; mx)
        reclassed[to_reclass] = f_ratios[i]
        if verbose:
            print(&#34;Min: {} Max: {} Range: {} Ratio: {}&#34;.format(
                mn, mx, vrange, f_ratios[i])
                 )
    return reclassed</code></pre>
</details>
</dd>
<dt id="frmod.analysis.show_grid"><code class="name flex">
<span>def <span class="ident">show_grid</span></span>(<span>grid, nodata, name='Grid', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot a grid, nodata values are masked.</p>
<p>Plot a grid (2D array). Values equal to nodata will be masked.
**kwargs are keywords passed to matplotplit.pyplot.imshow that
is used for plotting the masked grid. Eg. color maps (cmap).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>grid</code></strong> :&ensp;<code>Array</code></dt>
<dd>Grid to plot.</dd>
<dt><strong><code>nodata</code></strong> :&ensp;<code>int / float</code></dt>
<dd>Nodata value of the grid. Nodata values will be masked.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The title of the plot. The default is 'Grid'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_grid(grid, nodata, name=&#39;Grid&#39;, **kwargs):
    &#34;&#34;&#34;
    Plot a grid, nodata values are masked.

    Plot a grid (2D array). Values equal to nodata will be masked.
    **kwargs are keywords passed to matplotplit.pyplot.imshow that
    is used for plotting the masked grid. Eg. color maps (cmap).

    Parameters
    ----------
    grid : Array
        Grid to plot.
    nodata : int / float
        Nodata value of the grid. Nodata values will be masked.
    name : str, optional
        The title of the plot. The default is &#39;Grid&#39;.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    masked_grid = np.ma.masked_where((grid == nodata), grid)
    plt.figure()
    plt.title(name)
    plt.imshow(masked_grid, **kwargs)
    plt.colorbar()
    plt.show()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="frmod.analysis.FRAnalysis"><code class="flex name class">
<span>class <span class="ident">FRAnalysis</span></span>
<span>(</span><span>ls_mask, var_list)</span>
</code></dt>
<dd>
<div class="desc"><p>Frequency ratio analysis of a LandslideMask and a list of VRasters.</p>
<p>The steps of the analysis:</p>
<ol>
<li>run_analysis() is run upon instantiation for each fold of the
ls_mask and each VRaster. This yields the frequency ratio statistics
and the reclassified grids.</li>
<li>get_result() Compute the susceptibility grid and other related data.</li>
<li>get_src() Compute the success rate curves.
The success rate curve is the cumulative frequency distribution
of the landslide cells in the susceptibility categories.
Computed for each fold.</li>
<li>get_auc() Compute the area under the success rate curves for scoring.
Computed for each fold, then averaged for an overall score.
Smaller values are better.</li>
</ol>
<p>Create the FRAnalysis object.</p>
<p>Create the FRAnalysis object and its instanced variables.
The last step of the instantiation is creating the rc_folds list.
The rc_folds holds the reclassified VRaster.grid-s for the folds
of the ls_mask for each VRaster in the var_list.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ls_mask</code></strong> :&ensp;<code><a title="frmod.analysis.LandslideMask" href="#frmod.analysis.LandslideMask">LandslideMask</a></code></dt>
<dd>The LandslideMask object for the analysis.</dd>
<dt><strong><code>var_list</code></strong> :&ensp;<code>list</code></dt>
<dd>List of VRaster objects to be analyzed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FRAnalysis():
    &#34;&#34;&#34;Frequency ratio analysis of a LandslideMask and a list of VRasters.

    The steps of the analysis:

    1. run_analysis() is run upon instantiation for each fold of the
        ls_mask and each VRaster. This yields the frequency ratio statistics
        and the reclassified grids.
    2. get_result() Compute the susceptibility grid and other related data.
    3. get_src() Compute the success rate curves.
        The success rate curve is the cumulative frequency distribution
        of the landslide cells in the susceptibility categories.
        Computed for each fold.
    4. get_auc() Compute the area under the success rate curves for scoring.
        Computed for each fold, then averaged for an overall score.
        Smaller values are better.
    &#34;&#34;&#34;

    def __init__(self, ls_mask, var_list):
        &#34;&#34;&#34;
        Create the FRAnalysis object.

        Create the FRAnalysis object and its instanced variables.
        The last step of the instantiation is creating the rc_folds list.
        The rc_folds holds the reclassified VRaster.grid-s for the folds 
        of the ls_mask for each VRaster in the var_list.

        Parameters
        ----------
        ls_mask : LandslideMask
            The LandslideMask object for the analysis.
        var_list : list
            List of VRaster objects to be analyzed.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        # Input LandslideMask
        self.ls_mask = ls_mask
        # List of input VRasters
        self.var_list = var_list
        # Number of VRasters
        self.var_count = len(var_list)

        # AUC, area under the success rate curve
        # Sum of the success_rates of the folds
        self.auc_folds = []
        # Mean AUC
        self.auc_mean = None
        # Standard deviations of the AUCs
        self.auc_std = None

        # Percentile bins of the fresult
        self.ranks = None
        # Fold_susceptibility, the susceptibility grids of the folds
        self.fold_susceptibility = None
        # Final result, the mean estimated susceptibility map over the folds.
        self.fresult = None
        # Final result in the percentile form
        self.percentile_grid = None

        # Susceptibility value bins for the percentiles
        self.valid_perc = []

        # The distributions of % ranks for the validation cells.
        self.v_dist = []
        # Bins for the above v_dist for conversion to percentiles
        self.v_bins = []

        # Frequency ratio analysis results for each VRaster and fold.
        self.stats = {}

        # Frequency ratio analysis results for each VRaster and fold.
        # keyword: VRaster.name
        # value: list of pd.DataFrames, 1 DF / fold
        self.fr_stats_full = {}

        # List of success rates for the folds.
        self.success_rates = None
        # pandas DataFrame of the success rates for the folds.
        self.src_df = None

        # Reclassified grids for each variable and fold
        # Shape: [var_count, ls_mask.fold_count, rows, columns]
        self.rc_folds = [self.run_analysis(vraster, self.ls_mask)
                         for vraster in self.var_list]

    def run_analysis(self, vrr, lsm):
        &#34;&#34;&#34;
        Frequency ratio analysis of one VRaster and the LandslideMask folds.

        Parameters
        ----------
        vrr : VRaster
            Supplies the grid and other parameters for the
            get_freq_ratios function.
        lsm : LandslideMask
            Supplies the input masks for the get_freq_ratios functions.

        Returns
        -------
        rc_folds : ndarray
            The reclassified grids after the frequency ratio analysis of the
            VRaster and each fold of the LandslideMask.
            Shape: (self.var_count, lsm.fold_count, vrr.shape[0], vrr.shape[1])

        &#34;&#34;&#34;
        # Array for storing the reclassified VRaster.grids for the folds
        rc_folds = []
        # Create arrays for the statistics
        all_frq_ratios = []
        all_hst_bins = []
        all_folds_statistics = []

        # Run the analysis with the training areas of the different folds
        # Iterating over the train_areas of the folds
        for msk in lsm.train_areas:
            fr_data = get_freq_ratios(vr=vrr.grid,
                                      mask=msk,
                                      binc=vrr.bins,
                                      nodata=vrr.nodata,
                                      categorical=vrr.categorical,
                                      normalize=False
                                      )
            frq_ratios = fr_data[0]
            hst_bins = fr_data[1]
            # pd.DataFrame with the densities and the frequency ratios
            all_folds_statistics.append(fr_data[2])
            # Prepare the statistics DataFrame
            all_frq_ratios.append(frq_ratios)
            all_hst_bins.append(hst_bins)
            # Reclassify the VRaster.grid
            reclassed = reclass_raster(vrr.grid, frq_ratios, hst_bins)
            # Append the reclassified VRaster.grid to rc_folds
            rc_folds.append(reclassed)

        # Adding all_folds_statistics DF to the fr_stats_full dict
        self.fr_stats_full[vrr.name] = all_folds_statistics

        # Creating the pd.DataFrame for the frequency ratio statistics
        mn = all_hst_bins[0][:-1]
        mx = all_hst_bins[0][1:]
        stat_df = pd.DataFrame({(vrr.name+&#39;_min&#39;): mn, (vrr.name+&#39;_max&#39;): mx})
        for i in range(0, lsm.fold_count):
            cname = &#34;fold_&#34;+str(i+1)
            stat_df.insert(i+2, cname, all_frq_ratios[i])
        # Add the stats pd.DataFrame to the stats dict
        self.stats[vrr.name] = stat_df
        return rc_folds

    def get_result(self):
        &#34;&#34;&#34;
        Get the susceptibility estimation and ranks.

        Returns
        -------
        self.ranks : ndarray
            Numpy array (101,) with the percentile bins.

        &#34;&#34;&#34;
        rc_folds = self.rc_folds
        valid_positions = self.ls_mask.valid_positions
        result = []
        percentile_result = []
        # percentile bins
        percentile_bins = [x * 0.01 for x in range(0, 101)]
        # Iterate over the folds of the ls_mask.
        for i in range(0, self.ls_mask.fold_count):
            fold_result = np.zeros(rc_folds[0][0].shape)
            # Iterate over the reclassified grids of fold #i
            for j in rc_folds:
                # Average the reclassified  grids of fold #i.
                fold_result += j[i] / self.var_count

            # Percentile bin edges for conversion to percentiles
            valid_perc = np.quantile(fold_result[fold_result &gt;= 0],
                                     percentile_bins,
                                     interpolation=&#39;nearest&#39;)

            self.valid_perc.append(valid_perc)
            v_to_score = fold_result[valid_positions[i]]
            v_dist, v_bins = np.histogram(v_to_score,
                                          valid_perc,
                                          density=False)

            v_dist = np.array(v_dist)
            v_dist = v_dist / sum(v_dist)
            # Append the probability density function to vdist
            self.v_dist.append(v_dist)
            self.v_bins.append(v_bins)
            result.append(fold_result)

        # fresult: cell by cell average of the result array
        fresult = sum(result) / self.ls_mask.fold_count

        # Assigning the results from the validation folds to the location
        # of the landslide mask
        for i in range(0, self.ls_mask.fold_count):
            fresult[valid_positions[i]] = result[i][valid_positions[i]]
        # Set all invalid values (&lt;0) to -99999 (nodata)
        fresult[fresult &lt; 0] = -99999

        # TODO Convert fold_susceptibility to percentiles
        self.fold_susceptibility = result
        self.fresult = fresult
        percentiles = [i*0.01 for i in range(0, 101)]
        self.ranks = np.quantile(fresult[fresult &gt; 0], percentiles)
        return self.ranks

    def get_src(self):
        &#34;&#34;&#34;
        Get success rate arrays for the folds.

        Returns
        -------
        success_rates : ndarray
            Cumulative sum of the v_dist arrays of the folds.

        &#34;&#34;&#34;
        success_rates = []
        for i in self.v_dist:
            success_rates.append(np.cumsum(i))
        self.success_rates = success_rates
        # Create the dataframe
        percentiles = [i + 1 for i in range(0, 100)]
        src_df = pd.DataFrame({&#34;percentile&#34;: percentiles})
        for i in range(0, self.ls_mask.fold_count):
            cname = &#34;fold_&#34;+str(i+1)
            src_df.insert(i+1, cname, success_rates[i])
        self.src_df = src_df
        return success_rates

    def get_auc(self):
        &#34;&#34;&#34;
        Get AUC, area under the success rate curve.

        Returns
        -------
        list
            AUC values for the folds.

        &#34;&#34;&#34;
        for i in self.success_rates:
            auc_of_fold = np.sum(i)
            self.auc_folds.append(auc_of_fold)
            print(&#34;Auc: {}&#34;.format(auc_of_fold))
        self.auc_mean = np.mean(self.auc_folds)
        self.auc_std = np.std(self.auc_folds)
        print(&#34;Mean score: {}; Std: {}&#34;.format(self.auc_mean, self.auc_std))
        return self.auc_folds

    def get_percentile_grid(self, show=False, **kwargs):
        &#34;&#34;&#34;
        Reclass the fresult to get its percentile form.

        Parameters
        ----------
        show : bool, optional
            Set True to plot the percentile_grid after computing it.
            The default is False.
        **kwargs :
            Keywords passed to show_grid.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        percent = [i for i in range(1, 101)]
        percentile_grid = reclass_raster(self.fresult, percent, self.ranks)
        self.percentile_grid = percentile_grid
        if show:
            show_grid(grid=percentile_grid,
                      nodata=-99999,
                      name=&#34;Susceptibility (percentiles)&#34;,
                      **kwargs)

    def save_src(self, folder=&#34;./output/&#34;, fname=&#34;src.csv&#34;):
        &#34;&#34;&#34;
        Save the success rates as csv.

        Parameters
        ----------
        folder : str, optional
            Path to the output folder. The default is &#34;./output/&#34;.
        fname : str, optional
            Output filename with extension. The default is &#34;src.csv&#34;.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        if os.path.isdir(folder) is False:
            os.makedirs(folder)
        output_path = folder+fname
        self.src_df.to_csv(output_path)

    def save_stats(self, folder=&#34;./output/&#34;, tag=&#34;&#34;):
        &#34;&#34;&#34;
        Save the frequency ratio statistics for each VRaster and fold.

        Parameters
        ----------
        folder : str, optional
            Path to the output folder. The default is &#34;./output/&#34;.
        tag : str, optional
            Tag inserted to the beginning of the file name.
            The default is &#34;&#34;.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        output_path = folder+tag
        # Create the folder directory if it doesn&#39;t exist.
        if os.path.isdir(folder) is False:
            os.makedirs(folder)

        for k, v in self.stats.items():
            v.to_csv(output_path+&#34;_{}.csv&#34;.format(str(k)))

    def show_results(self, **kwargs):
        &#34;&#34;&#34;
        Plot fresult with show_grid.

        Plot fresult, the raw estimated landslide susceptibility.
        **kwargs can be keywords passed to matplotlib.pyplot.imshow

        Returns
        -------
        None.

        &#34;&#34;&#34;
        if self.fresult.any(None):
            show_grid(grid=self.fresult,
                      nodata=-99999,
                      name=&#39;Estimated susceptibility&#39;,
                      **kwargs)
        else:
            print(&#34;Use get_result() first!&#34;)

    def plot_success_rates(self):
        &#34;&#34;&#34;
        Plot the success rate curves.

        The success rate curve shows the cumulative distribution of
        test landslide cells (pixels) in the susceptibility categories.

        Returns
        -------
        fig : figure.Figure
            A figure for the success rate curves.
        ax : matplotlib.axes.__subplots.AxesSubplot
           The axes of the figure.

        &#34;&#34;&#34;
        fig, ax = plt.subplots()
        label = 1
        for i in self.success_rates:
            ax.plot(i, label=label)
            label += 1
        ax.set_xlim(left=0, right=99)
        ax.set_ylim(bottom=0, top=1.0)
        diag_line, = ax.plot(ax.get_xlim(), ax.get_ylim(), ls=&#34;--&#34;, c=&#34;.3&#34;)
        ax.legend()
        plt.show()
        return fig, ax

    def plot_var_fold_fr(self, name, fold):
        &#34;&#34;&#34;
        Plot the densities and the frequency ratio for a fold of one variable.

        The function handles a pd.DataFrame from the fr_stats_full dict.
        The df DataFrame is selected in the following way:
        df = self.fr_stats_full[name][fold]

        Parameters
        ----------
        name : str
            A key in fr_stats_full.
        fold : int
            Index of the fold in the self.fr_stats_full[name] list.

        Returns
        -------
        fig : figure.Figure
            A figure with two subplots on top of each other.
        ax1 : matplotlib.axes.__subplots.AxesSubplot
            1st axes of the figure. Located in the top part.
        ax2 : matplotlib.axes.__subplots.AxesSubplot
            2nd axes of the figure. Located in the bottom part.
        line_LS : matplotlib.lines.Line2D
            The &#34;landslide&#34; line of the 1st axes.
        line_NLS : matplotlib.lines.Line2D
            The &#34;non-landslide&#34; line of the 1st axes.
        line_fr : matplotlib.lines.Line2D
            The frequency ratio curve on the 2nd axes.
            &#34;landslide&#34; line / &#34;non-landslide&#34; line

        &#34;&#34;&#34;
        df = self.fr_stats_full[name][fold]
        fig, (ax1, ax2) = plt.subplots(2, 1)
        ax1.set_xlabel(&#34;Distribution of {} values in the LS and NLS areas&#34;.
                       format(name))
        ax2.set_xlabel(&#34;{} - fold: {}&#34;.format(name, (fold + 1)))
        line_LS, = ax1.plot(df[&#34;min&#34;], df[&#34;LS_density&#34;])
        line_NLS, = ax1.plot(df[&#34;min&#34;], df[&#34;NLS_density&#34;])
        line_fr = ax2.plot(df[&#34;min&#34;], df[&#34;frequency_ratio&#34;])
        ax1.set_ylim(bottom=0)
        ax2.set_ylim(bottom=0)
        ax1.set_xlim(left=df[&#34;min&#34;][0])
        ax2.set_xlim(left=df[&#34;min&#34;][0])
        ax2.set_ylabel(&#34;Frequency ratio&#34;)
        plt.tight_layout()
        plt.show()
        # Return the parts of the figure
        return fig, ax1, ax2, line_LS, line_NLS, line_fr</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="frmod.analysis.FRAnalysis.get_auc"><code class="name flex">
<span>def <span class="ident">get_auc</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get AUC, area under the success rate curve.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>AUC values for the folds.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_auc(self):
    &#34;&#34;&#34;
    Get AUC, area under the success rate curve.

    Returns
    -------
    list
        AUC values for the folds.

    &#34;&#34;&#34;
    for i in self.success_rates:
        auc_of_fold = np.sum(i)
        self.auc_folds.append(auc_of_fold)
        print(&#34;Auc: {}&#34;.format(auc_of_fold))
    self.auc_mean = np.mean(self.auc_folds)
    self.auc_std = np.std(self.auc_folds)
    print(&#34;Mean score: {}; Std: {}&#34;.format(self.auc_mean, self.auc_std))
    return self.auc_folds</code></pre>
</details>
</dd>
<dt id="frmod.analysis.FRAnalysis.get_percentile_grid"><code class="name flex">
<span>def <span class="ident">get_percentile_grid</span></span>(<span>self, show=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Reclass the fresult to get its percentile form.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>show</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Set True to plot the percentile_grid after computing it.
The default is False.</dd>
</dl>
<p>**kwargs :
Keywords passed to show_grid.</p>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_percentile_grid(self, show=False, **kwargs):
    &#34;&#34;&#34;
    Reclass the fresult to get its percentile form.

    Parameters
    ----------
    show : bool, optional
        Set True to plot the percentile_grid after computing it.
        The default is False.
    **kwargs :
        Keywords passed to show_grid.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    percent = [i for i in range(1, 101)]
    percentile_grid = reclass_raster(self.fresult, percent, self.ranks)
    self.percentile_grid = percentile_grid
    if show:
        show_grid(grid=percentile_grid,
                  nodata=-99999,
                  name=&#34;Susceptibility (percentiles)&#34;,
                  **kwargs)</code></pre>
</details>
</dd>
<dt id="frmod.analysis.FRAnalysis.get_result"><code class="name flex">
<span>def <span class="ident">get_result</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the susceptibility estimation and ranks.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>self.ranks : ndarray</code></dt>
<dd>Numpy array (101,) with the percentile bins.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_result(self):
    &#34;&#34;&#34;
    Get the susceptibility estimation and ranks.

    Returns
    -------
    self.ranks : ndarray
        Numpy array (101,) with the percentile bins.

    &#34;&#34;&#34;
    rc_folds = self.rc_folds
    valid_positions = self.ls_mask.valid_positions
    result = []
    percentile_result = []
    # percentile bins
    percentile_bins = [x * 0.01 for x in range(0, 101)]
    # Iterate over the folds of the ls_mask.
    for i in range(0, self.ls_mask.fold_count):
        fold_result = np.zeros(rc_folds[0][0].shape)
        # Iterate over the reclassified grids of fold #i
        for j in rc_folds:
            # Average the reclassified  grids of fold #i.
            fold_result += j[i] / self.var_count

        # Percentile bin edges for conversion to percentiles
        valid_perc = np.quantile(fold_result[fold_result &gt;= 0],
                                 percentile_bins,
                                 interpolation=&#39;nearest&#39;)

        self.valid_perc.append(valid_perc)
        v_to_score = fold_result[valid_positions[i]]
        v_dist, v_bins = np.histogram(v_to_score,
                                      valid_perc,
                                      density=False)

        v_dist = np.array(v_dist)
        v_dist = v_dist / sum(v_dist)
        # Append the probability density function to vdist
        self.v_dist.append(v_dist)
        self.v_bins.append(v_bins)
        result.append(fold_result)

    # fresult: cell by cell average of the result array
    fresult = sum(result) / self.ls_mask.fold_count

    # Assigning the results from the validation folds to the location
    # of the landslide mask
    for i in range(0, self.ls_mask.fold_count):
        fresult[valid_positions[i]] = result[i][valid_positions[i]]
    # Set all invalid values (&lt;0) to -99999 (nodata)
    fresult[fresult &lt; 0] = -99999

    # TODO Convert fold_susceptibility to percentiles
    self.fold_susceptibility = result
    self.fresult = fresult
    percentiles = [i*0.01 for i in range(0, 101)]
    self.ranks = np.quantile(fresult[fresult &gt; 0], percentiles)
    return self.ranks</code></pre>
</details>
</dd>
<dt id="frmod.analysis.FRAnalysis.get_src"><code class="name flex">
<span>def <span class="ident">get_src</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get success rate arrays for the folds.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>success_rates</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Cumulative sum of the v_dist arrays of the folds.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_src(self):
    &#34;&#34;&#34;
    Get success rate arrays for the folds.

    Returns
    -------
    success_rates : ndarray
        Cumulative sum of the v_dist arrays of the folds.

    &#34;&#34;&#34;
    success_rates = []
    for i in self.v_dist:
        success_rates.append(np.cumsum(i))
    self.success_rates = success_rates
    # Create the dataframe
    percentiles = [i + 1 for i in range(0, 100)]
    src_df = pd.DataFrame({&#34;percentile&#34;: percentiles})
    for i in range(0, self.ls_mask.fold_count):
        cname = &#34;fold_&#34;+str(i+1)
        src_df.insert(i+1, cname, success_rates[i])
    self.src_df = src_df
    return success_rates</code></pre>
</details>
</dd>
<dt id="frmod.analysis.FRAnalysis.plot_success_rates"><code class="name flex">
<span>def <span class="ident">plot_success_rates</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the success rate curves.</p>
<p>The success rate curve shows the cumulative distribution of
test landslide cells (pixels) in the susceptibility categories.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>figure.Figure</code></dt>
<dd>A figure for the success rate curves.</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.axes.__subplots.AxesSubplot</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>The axes of the figure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_success_rates(self):
    &#34;&#34;&#34;
    Plot the success rate curves.

    The success rate curve shows the cumulative distribution of
    test landslide cells (pixels) in the susceptibility categories.

    Returns
    -------
    fig : figure.Figure
        A figure for the success rate curves.
    ax : matplotlib.axes.__subplots.AxesSubplot
       The axes of the figure.

    &#34;&#34;&#34;
    fig, ax = plt.subplots()
    label = 1
    for i in self.success_rates:
        ax.plot(i, label=label)
        label += 1
    ax.set_xlim(left=0, right=99)
    ax.set_ylim(bottom=0, top=1.0)
    diag_line, = ax.plot(ax.get_xlim(), ax.get_ylim(), ls=&#34;--&#34;, c=&#34;.3&#34;)
    ax.legend()
    plt.show()
    return fig, ax</code></pre>
</details>
</dd>
<dt id="frmod.analysis.FRAnalysis.plot_var_fold_fr"><code class="name flex">
<span>def <span class="ident">plot_var_fold_fr</span></span>(<span>self, name, fold)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the densities and the frequency ratio for a fold of one variable.</p>
<p>The function handles a pd.DataFrame from the fr_stats_full dict.
The df DataFrame is selected in the following way:
df = self.fr_stats_full[name][fold]</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>A key in fr_stats_full.</dd>
<dt><strong><code>fold</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the fold in the self.fr_stats_full[name] list.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>figure.Figure</code></dt>
<dd>A figure with two subplots on top of each other.</dd>
<dt><strong><code>ax1</code></strong> :&ensp;<code>matplotlib.axes.__subplots.AxesSubplot</code></dt>
<dd>1st axes of the figure. Located in the top part.</dd>
<dt><strong><code>ax2</code></strong> :&ensp;<code>matplotlib.axes.__subplots.AxesSubplot</code></dt>
<dd>2nd axes of the figure. Located in the bottom part.</dd>
<dt><strong><code>line_LS</code></strong> :&ensp;<code>matplotlib.lines.Line2D</code></dt>
<dd>The "landslide" line of the 1st axes.</dd>
<dt><strong><code>line_NLS</code></strong> :&ensp;<code>matplotlib.lines.Line2D</code></dt>
<dd>The "non-landslide" line of the 1st axes.</dd>
<dt><strong><code>line_fr</code></strong> :&ensp;<code>matplotlib.lines.Line2D</code></dt>
<dd>The frequency ratio curve on the 2nd axes.
"landslide" line / "non-landslide" line</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_var_fold_fr(self, name, fold):
    &#34;&#34;&#34;
    Plot the densities and the frequency ratio for a fold of one variable.

    The function handles a pd.DataFrame from the fr_stats_full dict.
    The df DataFrame is selected in the following way:
    df = self.fr_stats_full[name][fold]

    Parameters
    ----------
    name : str
        A key in fr_stats_full.
    fold : int
        Index of the fold in the self.fr_stats_full[name] list.

    Returns
    -------
    fig : figure.Figure
        A figure with two subplots on top of each other.
    ax1 : matplotlib.axes.__subplots.AxesSubplot
        1st axes of the figure. Located in the top part.
    ax2 : matplotlib.axes.__subplots.AxesSubplot
        2nd axes of the figure. Located in the bottom part.
    line_LS : matplotlib.lines.Line2D
        The &#34;landslide&#34; line of the 1st axes.
    line_NLS : matplotlib.lines.Line2D
        The &#34;non-landslide&#34; line of the 1st axes.
    line_fr : matplotlib.lines.Line2D
        The frequency ratio curve on the 2nd axes.
        &#34;landslide&#34; line / &#34;non-landslide&#34; line

    &#34;&#34;&#34;
    df = self.fr_stats_full[name][fold]
    fig, (ax1, ax2) = plt.subplots(2, 1)
    ax1.set_xlabel(&#34;Distribution of {} values in the LS and NLS areas&#34;.
                   format(name))
    ax2.set_xlabel(&#34;{} - fold: {}&#34;.format(name, (fold + 1)))
    line_LS, = ax1.plot(df[&#34;min&#34;], df[&#34;LS_density&#34;])
    line_NLS, = ax1.plot(df[&#34;min&#34;], df[&#34;NLS_density&#34;])
    line_fr = ax2.plot(df[&#34;min&#34;], df[&#34;frequency_ratio&#34;])
    ax1.set_ylim(bottom=0)
    ax2.set_ylim(bottom=0)
    ax1.set_xlim(left=df[&#34;min&#34;][0])
    ax2.set_xlim(left=df[&#34;min&#34;][0])
    ax2.set_ylabel(&#34;Frequency ratio&#34;)
    plt.tight_layout()
    plt.show()
    # Return the parts of the figure
    return fig, ax1, ax2, line_LS, line_NLS, line_fr</code></pre>
</details>
</dd>
<dt id="frmod.analysis.FRAnalysis.run_analysis"><code class="name flex">
<span>def <span class="ident">run_analysis</span></span>(<span>self, vrr, lsm)</span>
</code></dt>
<dd>
<div class="desc"><p>Frequency ratio analysis of one VRaster and the LandslideMask folds.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>vrr</code></strong> :&ensp;<code><a title="frmod.analysis.VRaster" href="#frmod.analysis.VRaster">VRaster</a></code></dt>
<dd>Supplies the grid and other parameters for the
get_freq_ratios function.</dd>
<dt><strong><code>lsm</code></strong> :&ensp;<code><a title="frmod.analysis.LandslideMask" href="#frmod.analysis.LandslideMask">LandslideMask</a></code></dt>
<dd>Supplies the input masks for the get_freq_ratios functions.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>rc_folds</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>The reclassified grids after the frequency ratio analysis of the
VRaster and each fold of the LandslideMask.
Shape: (self.var_count, lsm.fold_count, vrr.shape[0], vrr.shape[1])</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_analysis(self, vrr, lsm):
    &#34;&#34;&#34;
    Frequency ratio analysis of one VRaster and the LandslideMask folds.

    Parameters
    ----------
    vrr : VRaster
        Supplies the grid and other parameters for the
        get_freq_ratios function.
    lsm : LandslideMask
        Supplies the input masks for the get_freq_ratios functions.

    Returns
    -------
    rc_folds : ndarray
        The reclassified grids after the frequency ratio analysis of the
        VRaster and each fold of the LandslideMask.
        Shape: (self.var_count, lsm.fold_count, vrr.shape[0], vrr.shape[1])

    &#34;&#34;&#34;
    # Array for storing the reclassified VRaster.grids for the folds
    rc_folds = []
    # Create arrays for the statistics
    all_frq_ratios = []
    all_hst_bins = []
    all_folds_statistics = []

    # Run the analysis with the training areas of the different folds
    # Iterating over the train_areas of the folds
    for msk in lsm.train_areas:
        fr_data = get_freq_ratios(vr=vrr.grid,
                                  mask=msk,
                                  binc=vrr.bins,
                                  nodata=vrr.nodata,
                                  categorical=vrr.categorical,
                                  normalize=False
                                  )
        frq_ratios = fr_data[0]
        hst_bins = fr_data[1]
        # pd.DataFrame with the densities and the frequency ratios
        all_folds_statistics.append(fr_data[2])
        # Prepare the statistics DataFrame
        all_frq_ratios.append(frq_ratios)
        all_hst_bins.append(hst_bins)
        # Reclassify the VRaster.grid
        reclassed = reclass_raster(vrr.grid, frq_ratios, hst_bins)
        # Append the reclassified VRaster.grid to rc_folds
        rc_folds.append(reclassed)

    # Adding all_folds_statistics DF to the fr_stats_full dict
    self.fr_stats_full[vrr.name] = all_folds_statistics

    # Creating the pd.DataFrame for the frequency ratio statistics
    mn = all_hst_bins[0][:-1]
    mx = all_hst_bins[0][1:]
    stat_df = pd.DataFrame({(vrr.name+&#39;_min&#39;): mn, (vrr.name+&#39;_max&#39;): mx})
    for i in range(0, lsm.fold_count):
        cname = &#34;fold_&#34;+str(i+1)
        stat_df.insert(i+2, cname, all_frq_ratios[i])
    # Add the stats pd.DataFrame to the stats dict
    self.stats[vrr.name] = stat_df
    return rc_folds</code></pre>
</details>
</dd>
<dt id="frmod.analysis.FRAnalysis.save_src"><code class="name flex">
<span>def <span class="ident">save_src</span></span>(<span>self, folder='./output/', fname='src.csv')</span>
</code></dt>
<dd>
<div class="desc"><p>Save the success rates as csv.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>folder</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Path to the output folder. The default is "./output/".</dd>
<dt><strong><code>fname</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Output filename with extension. The default is "src.csv".</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_src(self, folder=&#34;./output/&#34;, fname=&#34;src.csv&#34;):
    &#34;&#34;&#34;
    Save the success rates as csv.

    Parameters
    ----------
    folder : str, optional
        Path to the output folder. The default is &#34;./output/&#34;.
    fname : str, optional
        Output filename with extension. The default is &#34;src.csv&#34;.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    if os.path.isdir(folder) is False:
        os.makedirs(folder)
    output_path = folder+fname
    self.src_df.to_csv(output_path)</code></pre>
</details>
</dd>
<dt id="frmod.analysis.FRAnalysis.save_stats"><code class="name flex">
<span>def <span class="ident">save_stats</span></span>(<span>self, folder='./output/', tag='')</span>
</code></dt>
<dd>
<div class="desc"><p>Save the frequency ratio statistics for each VRaster and fold.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>folder</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Path to the output folder. The default is "./output/".</dd>
<dt><strong><code>tag</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Tag inserted to the beginning of the file name.
The default is "".</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_stats(self, folder=&#34;./output/&#34;, tag=&#34;&#34;):
    &#34;&#34;&#34;
    Save the frequency ratio statistics for each VRaster and fold.

    Parameters
    ----------
    folder : str, optional
        Path to the output folder. The default is &#34;./output/&#34;.
    tag : str, optional
        Tag inserted to the beginning of the file name.
        The default is &#34;&#34;.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    output_path = folder+tag
    # Create the folder directory if it doesn&#39;t exist.
    if os.path.isdir(folder) is False:
        os.makedirs(folder)

    for k, v in self.stats.items():
        v.to_csv(output_path+&#34;_{}.csv&#34;.format(str(k)))</code></pre>
</details>
</dd>
<dt id="frmod.analysis.FRAnalysis.show_results"><code class="name flex">
<span>def <span class="ident">show_results</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot fresult with show_grid.</p>
<p>Plot fresult, the raw estimated landslide susceptibility.
**kwargs can be keywords passed to matplotlib.pyplot.imshow</p>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_results(self, **kwargs):
    &#34;&#34;&#34;
    Plot fresult with show_grid.

    Plot fresult, the raw estimated landslide susceptibility.
    **kwargs can be keywords passed to matplotlib.pyplot.imshow

    Returns
    -------
    None.

    &#34;&#34;&#34;
    if self.fresult.any(None):
        show_grid(grid=self.fresult,
                  nodata=-99999,
                  name=&#39;Estimated susceptibility&#39;,
                  **kwargs)
    else:
        print(&#34;Use get_result() first!&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="frmod.analysis.LandslideMask"><code class="flex name class">
<span>class <span class="ident">LandslideMask</span></span>
<span>(</span><span>name, path, ls_marker=1, nls_marker=0, fold_count=5)</span>
</code></dt>
<dd>
<div class="desc"><p>LandslideMask.</p>
<p>Create a LandslideMask object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the landslide mask.</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the file used as the mask in the analysis.</dd>
<dt><strong><code>ls_marker</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Value marking the landslide pixels.
The default is 1.</dd>
<dt><strong><code>nls_marker</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Value marking the non-landslide pixels.
Must be different from the nodata value.
The default is 0.</dd>
<dt><strong><code>fold_count</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The number of cross validation folds. The default is 5.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LandslideMask():
    &#34;&#34;&#34;LandslideMask.&#34;&#34;&#34;

    def __init__(self, name, path, ls_marker=1, nls_marker=0, fold_count=5):
        &#34;&#34;&#34;
        Create a LandslideMask object.

        Parameters
        ----------
        name : str
            Name of the landslide mask.
        path : str
            Path to the file used as the mask in the analysis.
        ls_marker : int, optional
            Value marking the landslide pixels.
            The default is 1.
        nls_marker : int, optional
            Value marking the non-landslide pixels.
            Must be different from the nodata value.
            The default is 0.
        fold_count : int, optional
            The number of cross validation folds. The default is 5.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        # Name of the LandslideMask
        self.name = name
        # Path to the input mask file.
        self.path = path
        # NoData value of the input mask file.
        self.nodata = utils.get_nodata_value(path)
        # 2D array representation of the input mask file.
        self.grid = utils.raster2array(path)
        # Value marking the landslide cells.
        self.ls_marker = ls_marker
        # Value marking the non-landslide cells. Different from nodata!
        self.nls_marker = nls_marker
        # Number of folds
        self.fold_count = fold_count
        # (fold_count no. of (2, n) size arrays) with the split positions
        self.split_locations = self.get_splits(folds=self.fold_count)
        # List of (train_areas, valid_positions) ndarray pairs.
        self.t_v = [self.get_train_area(a) for a in self.split_locations]
        # Training areas (1), validation cells count as non-landslide.
        # Input mask for get_freq_ratios.
        self.train_areas = [t_v[0] for t_v in self.t_v]
        # Positions of the validation cells.
        self.valid_positions = [t_v[1] for t_v in self.t_v]

    def get_splits(self, folds=5):
        &#34;&#34;&#34;
        Split the mask for cross validation.

        Parameters
        ----------
        folds : TYPE, optional
            Number of desired folds. The default is 5.

        Returns
        -------
        split_locations : list of ndarrays
            (fold_count no. of (2, n) size arrays) with the split positions.

        &#34;&#34;&#34;
        valid = np.array(np.nonzero(self.grid == self.ls_marker))
        valid_transposed = valid.T
        np.random.shuffle(valid_transposed)
        valid_transposed_split = np.array_split(valid_transposed, folds)
        split_locations = [i.T for i in valid_transposed_split]
        return split_locations

    def get_train_area(self, split_to_omit):
        &#34;&#34;&#34;
        Get the train_area grid and the validation cell positions.

        Parameters
        ----------
        split_to_omit : list
            List of the position of the validation cells. It is used
            to construct the valid_position array. Cells marked here
            are turned into non-landslide cells.

        Returns
        -------
        train_area : list
            List of train area grids. Similar format to the self.grid.
        valid_position : list
            Lists the positions of the validation cells for the folds.
            Positions are given as two arrays:
                1st: row index increasing from top to bottom.
                2nd: column index increasing from left to right.

        &#34;&#34;&#34;
        train_area = np.copy(self.grid)
        valid_position = (split_to_omit[0], split_to_omit[1])
        train_area[valid_position] = self.nls_marker
        return train_area, valid_position

    def show(self, cmap=&#39;Accent&#39;):
        &#34;&#34;&#34;
        Plot the LandslideMask.grid.

        Parameters
        ----------
        cmap : str, optional
            Must be the name of a built-in Matplotlib colormap.
            The default is &#39;Accent&#39;.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        show_grid(self.grid, self.nodata, name=self.name, cmap=cmap)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="frmod.analysis.LandslideMask.get_splits"><code class="name flex">
<span>def <span class="ident">get_splits</span></span>(<span>self, folds=5)</span>
</code></dt>
<dd>
<div class="desc"><p>Split the mask for cross validation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>folds</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>Number of desired folds. The default is 5.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>split_locations</code></strong> :&ensp;<code>list</code> of <code>ndarrays</code></dt>
<dd>(fold_count no. of (2, n) size arrays) with the split positions.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_splits(self, folds=5):
    &#34;&#34;&#34;
    Split the mask for cross validation.

    Parameters
    ----------
    folds : TYPE, optional
        Number of desired folds. The default is 5.

    Returns
    -------
    split_locations : list of ndarrays
        (fold_count no. of (2, n) size arrays) with the split positions.

    &#34;&#34;&#34;
    valid = np.array(np.nonzero(self.grid == self.ls_marker))
    valid_transposed = valid.T
    np.random.shuffle(valid_transposed)
    valid_transposed_split = np.array_split(valid_transposed, folds)
    split_locations = [i.T for i in valid_transposed_split]
    return split_locations</code></pre>
</details>
</dd>
<dt id="frmod.analysis.LandslideMask.get_train_area"><code class="name flex">
<span>def <span class="ident">get_train_area</span></span>(<span>self, split_to_omit)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the train_area grid and the validation cell positions.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>split_to_omit</code></strong> :&ensp;<code>list</code></dt>
<dd>List of the position of the validation cells. It is used
to construct the valid_position array. Cells marked here
are turned into non-landslide cells.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>train_area</code></strong> :&ensp;<code>list</code></dt>
<dd>List of train area grids. Similar format to the self.grid.</dd>
<dt><strong><code>valid_position</code></strong> :&ensp;<code>list</code></dt>
<dd>Lists the positions of the validation cells for the folds.
Positions are given as two arrays:
1st: row index increasing from top to bottom.
2nd: column index increasing from left to right.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_train_area(self, split_to_omit):
    &#34;&#34;&#34;
    Get the train_area grid and the validation cell positions.

    Parameters
    ----------
    split_to_omit : list
        List of the position of the validation cells. It is used
        to construct the valid_position array. Cells marked here
        are turned into non-landslide cells.

    Returns
    -------
    train_area : list
        List of train area grids. Similar format to the self.grid.
    valid_position : list
        Lists the positions of the validation cells for the folds.
        Positions are given as two arrays:
            1st: row index increasing from top to bottom.
            2nd: column index increasing from left to right.

    &#34;&#34;&#34;
    train_area = np.copy(self.grid)
    valid_position = (split_to_omit[0], split_to_omit[1])
    train_area[valid_position] = self.nls_marker
    return train_area, valid_position</code></pre>
</details>
</dd>
<dt id="frmod.analysis.LandslideMask.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self, cmap='Accent')</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the LandslideMask.grid.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cmap</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Must be the name of a built-in Matplotlib colormap.
The default is 'Accent'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show(self, cmap=&#39;Accent&#39;):
    &#34;&#34;&#34;
    Plot the LandslideMask.grid.

    Parameters
    ----------
    cmap : str, optional
        Must be the name of a built-in Matplotlib colormap.
        The default is &#39;Accent&#39;.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    show_grid(self.grid, self.nodata, name=self.name, cmap=cmap)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="frmod.analysis.VRaster"><code class="flex name class">
<span>class <span class="ident">VRaster</span></span>
<span>(</span><span>name, path, bins=10, categorical=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Variable raster, input for frequency ratio analysis.</p>
<p>Create the VRaster object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the VRaster.</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the GDAL-compatible raster file.</dd>
<dt><strong><code>bins</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of histogram bins. The default is 10.</dd>
<dt><strong><code>categorical</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>True if it is a categorical variable, eg: geology.
The default is False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VRaster():
    &#34;&#34;&#34;Variable raster, input for frequency ratio analysis.&#34;&#34;&#34;

    def __init__(self, name, path, bins=10, categorical=False):
        &#34;&#34;&#34;
        Create the VRaster object.

        Parameters
        ----------
        name : str
            Name of the VRaster.
        path : str
            Path to the GDAL-compatible raster file.
        bins : int, optional
            Number of histogram bins. The default is 10.
        categorical : bool, optional
            True if it is a categorical variable, eg: geology.
            The default is False.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        self.name = name
        self.path = path
        self.bins = bins
        self.categorical = categorical
        self.nodata = utils.get_nodata_value(path)
        # Convert input grid to array
        self.grid = utils.raster2array(path)
        # Calculate basic statistics for the grid
        self.min = min(self.grid[self.grid != self.nodata])
        self.max = max(self.grid[self.grid != self.nodata])
        self.limits = (self.min, self.max)

    def show(self, **kwargs):
        &#34;&#34;&#34;
        Plot the VRaster.grid.

        Parameters
        ----------
        **kwargs :
            Keywords passed to show_grid.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        show_grid(self.grid, self.nodata, name=self.name, **kwargs)

    def show_info(self):
        &#34;&#34;&#34;
        Show basic information about the VRaster.grid.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        valid_values = self.grid[self.grid != self.nodata]
        if self.categorical:
            print(&#34;Categorical!&#34;)
        else:
            average = np.mean(valid_values)
            sdev = np.std(valid_values)
            print(&#34;Name: {} Limits: {}&#34;.format(self.name, self.limits))
            print(&#34;Mean: {} Standard deviation: {}&#34;.format(average, sdev))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="frmod.analysis.VRaster.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the VRaster.grid.</p>
<h2 id="parameters">Parameters</h2>
<p>**kwargs :
Keywords passed to show_grid.</p>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show(self, **kwargs):
    &#34;&#34;&#34;
    Plot the VRaster.grid.

    Parameters
    ----------
    **kwargs :
        Keywords passed to show_grid.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    show_grid(self.grid, self.nodata, name=self.name, **kwargs)</code></pre>
</details>
</dd>
<dt id="frmod.analysis.VRaster.show_info"><code class="name flex">
<span>def <span class="ident">show_info</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Show basic information about the VRaster.grid.</p>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_info(self):
    &#34;&#34;&#34;
    Show basic information about the VRaster.grid.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    valid_values = self.grid[self.grid != self.nodata]
    if self.categorical:
        print(&#34;Categorical!&#34;)
    else:
        average = np.mean(valid_values)
        sdev = np.std(valid_values)
        print(&#34;Name: {} Limits: {}&#34;.format(self.name, self.limits))
        print(&#34;Mean: {} Standard deviation: {}&#34;.format(average, sdev))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="frmod" href="index.html">frmod</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="frmod.analysis.get_freq_ratios" href="#frmod.analysis.get_freq_ratios">get_freq_ratios</a></code></li>
<li><code><a title="frmod.analysis.reclass_raster" href="#frmod.analysis.reclass_raster">reclass_raster</a></code></li>
<li><code><a title="frmod.analysis.show_grid" href="#frmod.analysis.show_grid">show_grid</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="frmod.analysis.FRAnalysis" href="#frmod.analysis.FRAnalysis">FRAnalysis</a></code></h4>
<ul class="two-column">
<li><code><a title="frmod.analysis.FRAnalysis.get_auc" href="#frmod.analysis.FRAnalysis.get_auc">get_auc</a></code></li>
<li><code><a title="frmod.analysis.FRAnalysis.get_percentile_grid" href="#frmod.analysis.FRAnalysis.get_percentile_grid">get_percentile_grid</a></code></li>
<li><code><a title="frmod.analysis.FRAnalysis.get_result" href="#frmod.analysis.FRAnalysis.get_result">get_result</a></code></li>
<li><code><a title="frmod.analysis.FRAnalysis.get_src" href="#frmod.analysis.FRAnalysis.get_src">get_src</a></code></li>
<li><code><a title="frmod.analysis.FRAnalysis.plot_success_rates" href="#frmod.analysis.FRAnalysis.plot_success_rates">plot_success_rates</a></code></li>
<li><code><a title="frmod.analysis.FRAnalysis.plot_var_fold_fr" href="#frmod.analysis.FRAnalysis.plot_var_fold_fr">plot_var_fold_fr</a></code></li>
<li><code><a title="frmod.analysis.FRAnalysis.run_analysis" href="#frmod.analysis.FRAnalysis.run_analysis">run_analysis</a></code></li>
<li><code><a title="frmod.analysis.FRAnalysis.save_src" href="#frmod.analysis.FRAnalysis.save_src">save_src</a></code></li>
<li><code><a title="frmod.analysis.FRAnalysis.save_stats" href="#frmod.analysis.FRAnalysis.save_stats">save_stats</a></code></li>
<li><code><a title="frmod.analysis.FRAnalysis.show_results" href="#frmod.analysis.FRAnalysis.show_results">show_results</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="frmod.analysis.LandslideMask" href="#frmod.analysis.LandslideMask">LandslideMask</a></code></h4>
<ul class="">
<li><code><a title="frmod.analysis.LandslideMask.get_splits" href="#frmod.analysis.LandslideMask.get_splits">get_splits</a></code></li>
<li><code><a title="frmod.analysis.LandslideMask.get_train_area" href="#frmod.analysis.LandslideMask.get_train_area">get_train_area</a></code></li>
<li><code><a title="frmod.analysis.LandslideMask.show" href="#frmod.analysis.LandslideMask.show">show</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="frmod.analysis.VRaster" href="#frmod.analysis.VRaster">VRaster</a></code></h4>
<ul class="">
<li><code><a title="frmod.analysis.VRaster.show" href="#frmod.analysis.VRaster.show">show</a></code></li>
<li><code><a title="frmod.analysis.VRaster.show_info" href="#frmod.analysis.VRaster.show_info">show_info</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>